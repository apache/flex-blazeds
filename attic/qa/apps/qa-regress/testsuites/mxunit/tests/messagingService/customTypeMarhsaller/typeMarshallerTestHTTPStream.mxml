<?xml version="1.0"?>
<!--

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" creationComplete="setUp()">           
    
    <mx:Script>
    <![CDATA[
        import mx.events.PropertyChangeEvent;
        import qa.utils.TestTask;
        import qa.utils.TestTaskEvent;
        import mx.messaging.Producer;
        import mx.messaging.channels.AMFChannel;
        import mx.messaging.Consumer;   
        import mx.messaging.ChannelSet;
        import mx.messaging.Channel;
        import qa.mxunit.Assert;
        import qa.mxunit.MXUnitManager;
        import mx.messaging.messages.*;
        import mx.messaging.config.*;
        import mx.messaging.events.*;
 
        ////////////////////////////////////////////////////////////////////////////
        //
        // Variables
        //
        ////////////////////////////////////////////////////////////////////////////                          
        /**
        *  Consumer instance used in the test. 
        */ 
        private var con:Consumer; 
        /**
         * Name of the channel to use for testing
         */ 
        private var currentTest:String = "qa-streaming-http-custom-marshaller";
        /**
        *  Name of the destination to be used by the Producer and the Consumer. 
        */
        private var destination:String = "MyTopicCustomMarshaller";          
        
        /**
        *  Used to store the expected results to compare to actual results in message received by consumer. 
        */
        private var expectedCollection:Object;
        
        /**
         *  Allows handlers to be removed, queued, etc. across async response handling.
         */
        public static var handler:Function;           
        
        /**
        *  Variable to hold singleton instance of the MXUnitManager.  
        */
        private var manager:MXUnitManager;
        /**
        * Producer instance used in the test. 
        */ 
        private var pro:Producer;
       
        ////////////////////////////////////////////////////////////////////////////
        //
        // Setup method.
        //
        //////////////////////////////////////////////////////////////////////////// 
        
        /**
        *  This setup method sets up the MXUnitManager
        */
        public function setUp():void {                                                                          
            //configure the MXUnitManager           
            manager = MXUnitManager.getInstance();                                                           
            
            //Call addTests giving it the object that contains all our test functions and an array of test names
            manager.addTests(this,["simpleMessageTest"], 10000);                        
        }
        ////////////////////////////////////////////////////////////////////////////
        //
        // Tests.
        //
        ////////////////////////////////////////////////////////////////////////////         
      
        /**
        *  Test that messages can be sent and received over a streaming http channel that 
        *  use a custom type marshaller. 
        * <serialization>
        *        <type-marshaller>qa.messaging.CustomTypeMarshaller</type-marshaller>
        * </serialization>
        */
        public function simpleMessageTest():void {  
            
            //setup the producer
            pro = new Producer();
            pro.destination = destination;
            
            //setup the consumer
            con = new Consumer(); 
            con.destination = destination;
            
            //hardcode channelset for the producer and consumer
            var channelSet:ChannelSet = new ChannelSet();
            var channel:Channel = ServerConfig.getChannel(currentTest);
            channelSet.addChannel(channel);
            pro.channelSet = channelSet;
            con.channelSet = channelSet;
            
            
            /*
             * Use the chain method to setup event handlers for the producer and push an addAsync method onto the stack. Receiving a 
             * message fault a channel fault or an acknowledgement that the server received the message sent by the producer will 
             * remove the addAsync method from the stack. Unless all addAsync methods have been executed the test will time out so 
             * you want to make sure that at least one of the events will get fired. This call is essentially the same as writing 
             * the following code: 
             * var asyncHandler = manager.currentTest.addAsync(producerEventHandler,{"c":con});
             * pro.addEventListener(ChannelFaultEvent.FAULT, asyncHandler);
             * pro.addEventListener(MessageFaultEvent.FAULT, asyncHandler);
             * pro.addEventListener(MessageAckEvent.ACKNOWLEDGE, asyncHandler);   
            */                                        
            manager.currentTest.chain(pro,[MessageFaultEvent.FAULT,ChannelFaultEvent.FAULT,MessageAckEvent.ACKNOWLEDGE],producerEventHandler);
            
            /*
             * Use the chain method to setup event handlers for the consumer and push an addAsync method onto the stack. Receiving a 
             * message fault a channel fault or a message event will cause the addAsync method to be removed from the stack.
             */
            manager.currentTest.chain(con,[MessageFaultEvent.FAULT,ChannelFaultEvent.FAULT,MessageEvent.MESSAGE],consumerEventHandler);
                         
            /*
            * Setup a property event listener to listen for property change events on the consumer so 
            * we can tell when the consumer has subscribed.
            */                        
            con.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE,consumerPropertyChanged); 
            con.subscribe();                           
            
        }
        /**
        *  Listen for property change events from the consumer so we can tell when the consumer has subscribed.    
        */
        private function consumerPropertyChanged(event:PropertyChangeEvent):void {
            if(event.property == "subscribed" && con.subscribed)
            {
                //test that the subscribe operation was for the channel we are currently testing                 
                Assert.assertTrue("Wrong channel: " + con.channelSet.currentChannel.id, con.channelSet.currentChannel.id == currentTest);                                
                //send the message
                var msg:IMessage = new AsyncMessage();
                msg.body =new TestTypedObject();
                msg.body.prop2="abc " + currentTest;
                msg.body.myNo=500;
                msg.body.theCollection=['b','a',3,new Date()];
                expectedCollection = msg.body.theCollection; 
                pro.send(msg);                  
            } 
        }
        
        /**
        *  Listen for disconnect events. Because we used chain (the same would be true had we used
        *  addAsync), the handler will get called by MXUnit instead of getting called directly by the 
        *  producer.  
        */
        public function channelDisconnect(event:ChannelEvent):void {    
            //assert that the consumer is no longer subscribed or connected
            Assert.assertTrue("Consumer shouldn't be subscribed", con.subscribed != true);
            Assert.assertTrue("Consumer shouldn't be connected", con.connected != true);
        }
        /**
        *  Listen for events from the producer.    
        */
        public function producerEventHandler(event:Event):void 
        {
            if (event is MessageAckEvent) {
                trace("Producer received ack for message");    
            } else if (event is ChannelFaultEvent) {
                con.unsubscribe();
                con.disconnect();
                var cfe:ChannelFaultEvent = event as ChannelFaultEvent;                        
                Assert.fail("Channel faulted with following error while sending message: " + cfe.faultDetail);     
            } else if (event is MessageFaultEvent) {
                con.unsubscribe();
                con.disconnect();
                var mfe:MessageFaultEvent = event as MessageFaultEvent;
                Assert.fail("Message fault while sending message: " + mfe.faultDetail);                
            }
        }
        /**
        *  Listen for events from the consumer. 
        */
        public function consumerEventHandler(event:Event):void
        {
            if (event is ChannelFaultEvent) {
                var cfe:ChannelFaultEvent = event as ChannelFaultEvent;                        
                Assert.fail("Consumer channel faulted with the following error: " + cfe.faultDetail);     
            } else if (event is MessageFaultEvent) {            
                var mfe:MessageFaultEvent = event as MessageFaultEvent;
                Assert.fail("Consumer got the following message fault: " + mfe.faultDetail);                
            } else if (event is MessageEvent) {                     
                var me:MessageEvent = event as MessageEvent;
                //get the message body from the message and store it.
                var result:Object = (event as MessageEvent).message.body;
                //do assertions on the results
                Assert.assertEquals("Wrong message: " + result, "abc " + currentTest, result.prop2);                        
                Assert.assertEquals("Message did not contain expected data: " + result, 500, result.myNo);
                Assert.assertEquals("Message did not contain expected data: " + result, expectedCollection[0], result.theCollection[0]);
                Assert.assertEquals("Message did not contain expected data: " + result, expectedCollection[1], result.theCollection[1]);
                Assert.assertEquals("Message did not contain expected data: " + result, expectedCollection[2], result.theCollection[2]);
                Assert.assertEquals("Message did not contain expected data: " + result, expectedCollection[3], result.theCollection[3]);
                handler = manager.currentTest.chain(con,[ChannelEvent.DISCONNECT],channelDisconnect);                                  
            }
            //disconnect the consumer
            con.unsubscribe();
            con.disconnect();
        }
       
    ]]>
    </mx:Script>           
</mx:Application>